<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Your Grandma is Funky</title>
  <style>
    /* Make sure the body fills the viewport */
    body,
    html {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      position: relative;
    }

    /* The canvas will be positioned as a full-screen background */
    canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      /* Behind the content */
    }

    /* Center the form vertically and horizontally */
    .form-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 10;
      /* Above the canvas */
      background: rgba(255, 255, 255, 0.9);
      /* Optional: add a background for readability */
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }
  </style>
</head>

<body>
  <!-- The form overlay -->
  <div class="form-container">
    <form>
      <h2>Contact Us</h2>
      <label for="name">Name:</label>
      <input type="text" id="name" name="name" required />
      <br><br>
      <label for="email">Email:</label>
      <input type="email" id="email" name="email" required />
      <br><br>
      <button type="submit">Submit</button>
    </form>
  </div>

  <!-- Include Three.js from a CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let scene, camera, renderer;
    let geometry, material, mesh;
    let clock;

    // For the mouse-based "gravity well"
    let raycaster, mouse;

    function init() {
      // 1. SCENE
      scene = new THREE.Scene();

      // 2. CAMERA
      camera = new THREE.PerspectiveCamera(
        55,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(5, 5, 10);   // Slightly above and "back"
      camera.lookAt(-5, 2, -10);

      // 3. RENDERER
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // 4. CREATE PLANE GEOMETRY & MESH
      const width = 70;
      const height = 100;
      const widthSegments = 100;
      const heightSegments = 100;

      geometry = new THREE.PlaneGeometry(width, height, widthSegments, heightSegments);
      material = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true });
      mesh = new THREE.Mesh(geometry, material);

      // Rotate plane so it's horizontal (like a "floor")
      mesh.rotation.x = -Math.PI / 2;
      scene.add(mesh);

      // 5. CLOCK FOR ANIMATION
      clock = new THREE.Clock();

      // 6. RAYCASTER + MOUSE for "gravity well"
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();

      // Listen for mouse move
      window.addEventListener('mousemove', onMouseMove, false);
      window.addEventListener('resize', onWindowResize, false);
    }

    function onMouseMove(event) {
      // Convert mouse position to normalized device coordinates (-1 to +1)
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    function animate() {
      requestAnimationFrame(animate);
      const time = clock.getElapsedTime();
      updateMeshVertices(time);
      renderer.render(scene, camera);
    }

    function updateMeshVertices(time) {
      // Update the raycaster based on the current mouse position.
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(mesh);
      let mouse3D = null;
      if (intersects.length > 0) {
        mouse3D = intersects[0].point.clone();
        // Apply an artificial offset so the gravity effect appears further away.
        const mouseOffset = 15; // Adjust this value as needed.
        // Because the plane was rotated (mesh.rotation.x = -Math.PI/2),
        // the geometry's y corresponds to world z.
        mouse3D.z += mouseOffset;
      }

      // Smoothing factor for vertex interpolation.
      const smoothingFactor = 0.1;
      const position = geometry.attributes.position;

      for (let i = 0; i < position.count; i++) {
        // Get the original x and y values from the geometry (local coordinates).
        const x = position.getX(i);
        const y = position.getY(i);

        // Calculate the base wave effect.
        const waveHeight = Math.sin((x + time) * 0.5) * Math.cos((y + time) * 0.5);

        // Calculate the gravity effect if we have a valid mouse position.
        let gravityOffset = 0;
        if (mouse3D) {
          // Because the plane is rotated, the geometry's y corresponds to world z.
          // So we compare geometry's x with mouse3D.x, and geometry's y with mouse3D.z.
          const dx = x - mouse3D.x;
          const dy = y - mouse3D.z;
          const dist = Math.sqrt(dx * dx + dy * dy);

          // Define an influence radius and maximum effect strength.
          const influenceRadius = 10;
          const maxEffect = 5;

          // Apply a linear falloff for vertices within the radius.
          if (dist < influenceRadius) {
            gravityOffset = (1 - dist / influenceRadius) * maxEffect;
          }
        }

        // The target Z value is the combination of wave and gravity effects.
        const targetZ = waveHeight + gravityOffset;

        // Retrieve the current Z value and interpolate toward the target value.
        const currentZ = position.getZ(i);
        const smoothZ = THREE.MathUtils.lerp(currentZ, targetZ, smoothingFactor);
        position.setZ(i, smoothZ);
      }
      // Inform Three.js that the geometry has been updated.
      position.needsUpdate = true;
    }

    init();
    animate();
  </script>
</body>

</html>